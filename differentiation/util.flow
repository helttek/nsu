import lingo/pegcode/driver;
import string;
import math/math;

export {
    ArExpr ::= ArSum, ArMult, ArDiv, ArSub, ArNeg, ArVar, ArInt;
    ArNeg(val : ArExpr);
    ArSum(lhs : ArExpr, rhs : ArExpr);
    ArMult(lhs : ArExpr, rhs : ArExpr);
    ArDiv(lhs : ArExpr, rhs : ArExpr);
    ArSub(lhs : ArExpr, rhs : ArExpr);
    ArInt(val : int);
    ArVar(val : string);
    ArFractNum : (numerator : int, denominator : int);

    Sum(lhs : Maybe<ArFractNum>, rhs : Maybe<ArFractNum>) -> Maybe<ArFractNum>;
    Sub(lhs : Maybe<ArFractNum>, rhs : Maybe<ArFractNum>) -> Maybe<ArFractNum>;
    Mult(lhs : Maybe<ArFractNum>, rhs : Maybe<ArFractNum>) -> Maybe<ArFractNum>;
    Div(lhs : Maybe<ArFractNum>, rhs : Maybe<ArFractNum>) -> Maybe<ArFractNum>;
    num2s(num : Maybe<ArFractNum>) -> string;
    calc(arExpr: ArExpr, vars : Tree<string, ArFractNum>) -> Maybe<ArFractNum>;
    arexpr2s(arExpr: ArExpr) -> string;
    Parse(str : string) -> ArExpr;
}

Sum(lhs : Maybe<ArFractNum>, rhs : Maybe<ArFractNum>) -> Maybe<ArFractNum> {
    if (isSome(lhs) && isSome(rhs)) {
        l = either(lhs, ArFractNum(0, 0));
        r = either(rhs, ArFractNum(0, 0));
        // a/b + c/d
        nok = lcm(l.denominator, r.denominator);
        resNumerator = nok / l.denominator * l.numerator + nok / r.denominator * r.numerator;
        resDenominator = nok;
        nod = iabs(gcd(resNumerator, resDenominator));
        Some(ArFractNum(resNumerator / nod, resDenominator / nod));
    } else {
        None();
    }
}

Sub(lhs : Maybe<ArFractNum>, rhs : Maybe<ArFractNum>) -> Maybe<ArFractNum> {
    if (isSome(lhs) && isSome(rhs)) {
        l = either(lhs, ArFractNum(0, 0));
        r = either(rhs, ArFractNum(0, 0));
        // a/b - c/d
        nok = lcm(l.denominator, r.denominator);
        resNumerator = nok / l.denominator * l.numerator - nok / r.denominator * r.numerator;
        resDenominator = nok;
        nod = iabs(gcd(resNumerator, resDenominator));
        Some(ArFractNum(resNumerator / nod, resDenominator / nod));
    } else {
        None();
    }
}

Mult(lhs : Maybe<ArFractNum>, rhs : Maybe<ArFractNum>) -> Maybe<ArFractNum> { 
    if (isSome(lhs) && isSome(rhs)) {
        l = either(lhs, ArFractNum(0, 0));
        r = either(rhs, ArFractNum(0, 0));
        // a/b * c/d
        nod_ad = iabs(gcd(l.numerator, r.denominator));
        nod_bc = iabs(gcd(r.numerator, l.denominator));
        resNumerator = l.numerator / nod_ad * r.numerator / nod_bc;
        resDenominator = l.denominator / nod_bc * r.denominator / nod_ad;
        nod = iabs(gcd(resNumerator, resDenominator));
        Some(ArFractNum(resNumerator / nod, resDenominator / nod));
    } else {
        None();
    }
}

Div(lhs : Maybe<ArFractNum>, rhs : Maybe<ArFractNum>) -> Maybe<ArFractNum> {
    if (isSome(lhs) && isSome(rhs)) {
        l = either(lhs, ArFractNum(0, 0));
        r = either(rhs, ArFractNum(0, 0));
        // (a/b) / (c/d) = (a*d) / (b*c)
        nod_ac = iabs(gcd(l.numerator, r.numerator));
        nod_bd = iabs(gcd(l.denominator, r.denominator));
        resNumerator = l.numerator / nod_ac * r.denominator / nod_bd;
        resDenominator = l.denominator / nod_bd * r.numerator / nod_ac;
        if (resDenominator == 0) {
            None();
        } else {
            nod = iabs(gcd(resNumerator, resDenominator));
            Some(ArFractNum(resNumerator / nod, resDenominator / nod));
        }
    } else {
        None();
    }
}

num2s(num : Maybe<ArFractNum>) -> string {
    if (isSome(num)) {
        tmp = either(num, ArFractNum(0, 0));
        if (tmp.denominator == 0) {
            "Division by zero";
        } else {
            if (tmp.denominator == 1){
                i2s(tmp.numerator);
            } else {
                i2s(tmp.numerator) + "/" + i2s(tmp.denominator);
            }
        }
    } else {
        "Bad number format or division by zero";
    }
}

calc(arExpr: ArExpr, vars : Tree<string, ArFractNum>) -> Maybe<ArFractNum> {
    switch (arExpr) {
        ArNeg(val): Mult(Some(ArFractNum(-1,1)), calc(val, vars));
        ArSum(lhs, rhs): Sum(calc(lhs, vars), calc(rhs, vars));
        ArSub(lhs, rhs): Sub(calc(lhs, vars), calc(rhs, vars));
        ArMult(lhs, rhs): Mult(calc(lhs, vars), calc(rhs, vars));
        ArDiv(lhs, rhs): Div(calc(lhs, vars), calc(rhs, vars));
        ArInt(val): Some(ArFractNum(val, 1));
        ArVar(val): lookupTree(vars, val);
    }
}

arexpr2s(arExpr: ArExpr) -> string {
    switch (arExpr) {
        ArNeg(val): "(-" + arexpr2s(val) + ")";
        ArSum(lhs, rhs): "(" + arexpr2s(lhs) + " + " + arexpr2s(rhs) + ")";
        ArSub(lhs, rhs): "(" + arexpr2s(lhs) + " - " + arexpr2s(rhs) + ")";
        ArMult(lhs, rhs): "(" + arexpr2s(lhs) + " * " + arexpr2s(rhs) + ")";
        ArDiv(lhs, rhs): "(" + arexpr2s(lhs) + " / " + arexpr2s(rhs) + ")";
        ArInt(val): i2s(val);
        ArVar(val): val;
    }
}

Parse(str : string) -> ArExpr {
    compiled_grammar = compilePegGrammar("#include ../extended_calculator/main.lingo");
    parsic(compiled_grammar, str, defaultPegActions);
}
